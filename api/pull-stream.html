<html>
    <head>
    <title>Pull Stream - Documentation - SSBC</title>
    <link rel="stylesheet" href="/normalize.css">
    <link rel="stylesheet" href="/styles.css">
    <link rel="stylesheet" href="/monokai.css">
    <script src="/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
    <body>
      <div id="leftnav">
    <div class="leftnav-item ">
      <a href="/patchwork" title="Patchwork">Patchwork<br><small>Messaging App</small></a>
    </div>
    <div class="leftnav-subitems">
      <div class="leftnav-item ">
      <a href="/docs/patchwork/install.html" title="Install">Install</a>
    </div>
      <div class="leftnav-item ">
      <a href="/docs/patchwork/help-faq.html" title="Help / FAQ">Help / FAQ</a>
    </div>
    </div>
    <div class="leftnav-item ">
      <a href="/scuttlebot" title="Scuttlebot">Scuttlebot<br><small>P2P Database</small></a>
    </div>
    <div class="leftnav-subitems">
      <div class="leftnav-item ">
      <a href="/docs/sbot/install.html" title="Install">Install</a>
    </div>
      <div class="leftnav-item ">
      <a href="/docs/sbot/tutorial.html" title="Tutorial">Tutorial</a>
    </div>
      <div class="leftnav-item ">
      <a href="/docs/sbot/howto-setup-a-pub.html" title="HOWTO: Setup a Pub">HOWTO: Setup a Pub</a>
    </div>
    </div>
    <div class="leftnav-item ">
      <a href="/secure-scuttlebutt" title="Secure Scuttlebutt">Secure Scuttlebutt<br><small>Database Protocol</small></a>
    </div>
    <div class="leftnav-subitems">
      <div class="leftnav-item ">
      <a href="/docs/ssb/learn.html" title="Learn about the Protocol">Learn about the Protocol</a>
    </div>
      <div class="leftnav-item ">
      <a href="/docs/ssb/secret-handshake.html" title="Secret Handshake">Secret Handshake</a>
    </div>
      <div class="leftnav-item ">
      <a href="/docs/ssb/end-to-end-encryption.html" title="End-to-end Encryption">End-to-end Encryption</a>
    </div>
    </div>
    <div class="leftnav-item">API Documentation</div>
    <div class="leftnav-subitems">
      <div class="leftnav-item ">
      <a href="/docs/api/scuttlebot.html" title="scuttlebot">scuttlebot</a>
    </div>
      <div class="leftnav-indent">
        <div class="leftnav-item ">
      <a href="/docs/api/scuttlebot-blobs.html" title="blobs">blobs</a>
    </div>
        <div class="leftnav-item ">
      <a href="/docs/api/scuttlebot-block.html" title="block">block</a>
    </div>
        <div class="leftnav-item ">
      <a href="/docs/api/scuttlebot-friends.html" title="friends">friends</a>
    </div>
        <div class="leftnav-item ">
      <a href="/docs/api/scuttlebot-gossip.html" title="gossip">gossip</a>
    </div>
        <div class="leftnav-item ">
      <a href="/docs/api/scuttlebot-invite.html" title="invite">invite</a>
    </div>
        <div class="leftnav-item ">
      <a href="/docs/api/scuttlebot-replicate.html" title="replicate">replicate</a>
    </div>
      </div>
      <div class="leftnav-item ">
      <a href="/docs/api/ssb-msgs.html" title="ssb-msgs">ssb-msgs</a>
    </div>
      <div class="leftnav-item ">
      <a href="/docs/api/ssb-msg-schemas.html" title="ssb-msg-schemas">ssb-msg-schemas</a>
    </div>
      <div class="leftnav-item ">
      <a href="/docs/api/ssb-ref.html" title="ssb-ref">ssb-ref</a>
    </div>
      <div class="leftnav-item ">
      <a href="/docs/api/ssb-keys.html" title="ssb-keys">ssb-keys</a>
    </div>
      <div class="leftnav-item ">
      <a href="/docs/api/ssb-config.html" title="ssb-config">ssb-config</a>
    </div>
      <div class="leftnav-item ">
      <a href="/docs/api/secret-stack.html" title="secret-stack">secret-stack</a>
    </div>
      <div class="leftnav-item ">
      <a href="/docs/api/muxrpc.html" title="muxrpc">muxrpc</a>
    </div>
      <div class="leftnav-item selected">
      <a href="/docs/api/pull-stream.html" title="pull-stream">pull-stream</a>
    </div>
    </div>
    <div class="leftnav-item">Articles</div>
    <div class="leftnav-subitems">
      <div class="leftnav-item ">
      <a href="/docs/articles/design-challenge-avoid-centralization-and-singletons.html" title="Design Challenge: Avoiding Centralization and Singletons">Design Challenge: Avoiding Centralization and Singletons</a>
    </div>
      <div class="leftnav-item ">
      <a href="/docs/articles/design-challenge-sybil-attack.html" title="Design Challenge: Sybil Attacks">Design Challenge: Sybil Attacks</a>
    </div>
      <div class="leftnav-item ">
      <a href="/docs/articles/desirable-properties-for-a-secure-channel.html" title="Desirable Properties for a Secure Channel">Desirable Properties for a Secure Channel</a>
    </div>
      <div class="leftnav-item ">
      <a href="/docs/articles/secure-private-channels.html" title="Secure, Private Channels: the Good, the Bad, and the Ugly">Secure, Private Channels: the Good, the Bad, and the Ugly</a>
    </div>
      <div class="leftnav-item ">
      <a href="/docs/articles/using-reputation-in-open-networks.html" title="Using Reputation in Open Networks">Using Reputation in Open Networks</a>
    </div>
    </div>
  </div>
      <div id="content">
        <h1 id="pull-stream">pull-stream</h1>
<p>Minimal Pipeable Pull-stream</p>
<p>In <a href="1">classic-streams</a>,
streams <em>push</em> data to the next stream in the pipeline.
In <a href="https://github.com/joyent/node/blob/v0.10/doc/api/stream.markdown">new-streams</a>,
data is pulled out of the source stream, into the destination.
In [new-classic-streams](
<code>pull-stream</code> is a minimal take on streams,
pull streams work great for &quot;object&quot; streams as well as streams of raw text or binary data.</p>
<h2 id="quick-example">Quick Example</h2>
<p>Stat some files:</p>
<pre><code class="lang-js">pull(
  pull.values([&#39;file1&#39;, &#39;file2&#39;, &#39;file3&#39;]),
  pull.asyncMap(fs.stat),
  pull.collect(function (err, array) {
    console.log(array)
  })
)
</code></pre>
<p>note that <code>pull(a, b, c)</code> is basically the same as <code>a.pipe(b).pipe(c)</code>.</p>
<p>The best thing about pull-stream is that it can be completely lazy.
This is perfect for async traversals where you might want to stop early.</p>
<h2 id="compatibily-with-node-streams">Compatibily with node streams</h2>
<p>pull-streams are not <em>directly</em> compatible with node streams,
but pull-streams can be converted into node streams with
<a href="https://github.com/dominictarr/pull-stream-to-stream">pull-stream-to-stream</a>
and node streams can be converted into pull-stream using <a href="https://github.com/dominictarr/stream-to-pull-stream">stream-to-pull-stream</a></p>
<h3 id="readable-reader-vs-readable-writable">Readable &amp; Reader vs. Readable &amp; Writable</h3>
<p>Instead of a readable stream, and a writable stream, there is a <code>readable</code> stream,
 (aka &quot;Source&quot;) and a <code>reader</code> stream (aka &quot;Sink&quot;). Through streams
is a Sink that returns a Source.</p>
<p>See also:</p>
<ul>
<li><a href="https://github.com/dominictarr/pull-stream/blob/master/docs/sources.md">Sources</a></li>
<li><a href="https://github.com/dominictarr/pull-stream/blob/master/docs/throughs.md">Throughs</a></li>
<li><a href="https://github.com/dominictarr/pull-stream/blob/master/docs/sinks.md">Sinks</a></li>
</ul>
<h3 id="source-aka-readable-">Source (aka, Readable)</h3>
<p>The readable stream is just a <code>function read(end, cb)</code>,
that may be called many times,
and will (asynchronously) <code>cb(null, data)</code> once for each call.</p>
<p>To signify an end state, the stream eventually returns <code>cb(err)</code> or <code>cb(true)</code>.
When indicating a terminal state, <code>data</code> <em>must</em> be ignored.</p>
<p>The <code>read</code> function <em>must not</em> be called until the previous call has called back.
Unless, it is a call to abort the stream (<code>read(truthy, cb)</code>).</p>
<pre><code class="lang-js">//a stream of 100 random numbers.
var i = 100
var random = function () {
  return function (end, cb) {
    if(end) return cb(end)
    //only read 100 times
    if(i-- &lt; 0) return cb(true)
    cb(null, Math.random())
  }
}
</code></pre>
<h3 id="sink-aka-reader-writable-">Sink; (aka, Reader, &quot;writable&quot;)</h3>
<p>A sink is just a <code>reader</code> function that calls a Source (read function),
until it decideds to stop, or the readable ends. <code>cb(err || true)</code></p>
<p>All <a href="https://github.com/dominictarr/pull-stream/blob/master/docs/throughs.md">Throughs</a>
and <a href="https://github.com/dominictarr/pull-stream/blob/master/docs/sinks.md">Sinks</a>
are reader streams.</p>
<pre><code class="lang-js">//read source and log it.
var logger = function (read) {
  read(null, function next(end, data) {
    if(end === true) return
    if(end) throw end

    console.log(data)
    read(null, next)
  })
}
</code></pre>
<p>Since these are just functions, you can pass them to each other!</p>
<pre><code class="lang-js">var rand = random())
var log = logger()

log(rand) //&quot;pipe&quot; the streams.
</code></pre>
<p>but, it&#39;s easier to read if you use&#39;s pull-stream&#39;s <code>pull</code> method</p>
<pre><code class="lang-js">var pull = require(&#39;pull-stream&#39;)

pull(random(), logger())
</code></pre>
<h3 id="through">Through</h3>
<p>A through stream is a reader on one end and a readable on the other.
It&#39;s Sink that returns a Source.
That is, it&#39;s just a function that takes a <code>read</code> function,
and returns another <code>read</code> function.</p>
<pre><code class="lang-js">var map = function (read, map) {
  //return a readable function!
  return function (end, cb) {
    read(end, function (end, data) {
      cb(end, data != null ? map(data) : null)
    })
  }
}
</code></pre>
<h3 id="pipeability">Pipeability</h3>
<p>Every pipeline must go from a <code>source</code> to a <code>sink</code>.
Data will not start moving until the whole thing is connected.</p>
<pre><code class="lang-js">pull(source, through, sink)
</code></pre>
<p>some times, it&#39;s simplest to describe a stream in terms of other streams.
pull can detect what sort of stream it starts with (by counting arguments)
and if you pull together through streams, it gives you a new through stream.</p>
<pre><code class="lang-js">var tripleThrough =
  pull(through1(), through2(), through3())
//THE THREE THROUGHS BECOME ONE

pull(source(), tripleThrough, sink())
</code></pre>
<p>pull detects if it&#39;s missing a Source by checking function arity,
if the function takes only one argument it&#39;s either a sink or a through.
Otherwise it&#39;s a Source.</p>
<h2 id="duplex-streams">Duplex Streams</h2>
<p>Duplex streams, which are used to communicate between two things,
(i.e. over a network) are a little different. In a duplex stream,
messages go both ways, so instead of a single function that represents the stream,
you need a pair of streams. <code>{source: sourceStream, sink: sinkStream}</code></p>
<p>pipe duplex streams like this:</p>
<pre><code class="lang-js">var a = duplex()
var b = duplex()

pull(a.source, b.sink)
pull(b.source, a.sink)

//which is the same as

b.sink(a.source); a.sink(b.source)

//but the easiest way is to allow pull to handle this

pull(a, b, a)

//&quot;pull from a to b and then back to a&quot;
</code></pre>
<h2 id="design-goals-rationale">Design Goals &amp; Rationale</h2>
<p>There is a deeper,
<a href="http://en.wikipedia.org/wiki/Platonic_idealism">platonic abstraction</a>,
where a streams is just an array in time, instead of in space.
And all the various streaming &quot;abstractions&quot; are just crude implementations
of this abstract idea.</p>
<p><a href="https://github.com/joyent/node/blob/v0.8.16/doc/api/stream.markdown">classic-streams</a>,
<a href="https://github.com/joyent/node/blob/v0.10/doc/api/stream.markdown">new-streams</a>,
<a href="https://github.com/Gozala/reducers">reducers</a></p>
<p>The objective here is to find a simple realization of the best features of the above.</p>
<h3 id="type-agnostic">Type Agnostic</h3>
<p>A stream abstraction should be able to handle both streams of text and streams
of objects.</p>
<h3 id="a-pipeline-is-also-a-stream-">A pipeline is also a stream.</h3>
<p>Something like this should work: <code>a.pipe(x.pipe(y).pipe(z)).pipe(b)</code>
this makes it possible to write a custom stream simply by
combining a few available streams.</p>
<h3 id="propagate-end-error-conditions-">Propagate End/Error conditions.</h3>
<p>If a stream ends in an unexpected way (error),
then other streams in the pipeline should be notified.
(this is a problem in node streams - when an error occurs,
the stream is disconnected, and the user must handle that specially)</p>
<p>Also, the stream should be able to be ended from either end.</p>
<h3 id="transparent-backpressure-laziness">Transparent Backpressure &amp; Laziness</h3>
<p>Very simple transform streams must be able to transfer back pressure
instantly.</p>
<p>This is a problem in node streams, pause is only transfered on write, so
on a long chain (<code>a.pipe(b).pipe(c)</code>), if <code>c</code> pauses, <code>b</code> will have to write to it
to pause, and then <code>a</code> will have to write to <code>b</code> to pause.
If <code>b</code> only transforms <code>a</code>&#39;s output, then <code>a</code> will have to write to <code>b</code> twice to
find out that <code>c</code> is paused.</p>
<p><a href="https://github.com/Gozala/reducers">reducers</a> reducers has an interesting method,
where synchronous tranformations propagate back pressure instantly!</p>
<p>This means you can have two &quot;smart&quot; streams doing io at the ends, and lots of dumb
streams in the middle, and back pressure will work perfectly, as if the dumb streams
are not there.</p>
<p>This makes laziness work right.</p>
<h3 id="handling-end-error-and-abort-">handling end, error, and abort.</h3>
<p>in pull streams, any part of the stream (source, sink, or through)
may terminate the stream. (this is the case with node streams too,
but it&#39;s not handled well).</p>
<h4 id="source-end-error">source: end, error</h4>
<p>A source may end (<code>cb(true)</code> after read) or error (<code>cb(error)</code> after read)
After ending, the source <em>must</em> never <code>cb(null, data)</code></p>
<h4 id="sink-abort">sink: abort</h4>
<p>Sinks do not normally end the stream, but if they decide they do
not need any more data they may &quot;abort&quot; the source by calling <code>read(true, cb)</code>.
A abort (<code>read(true, cb)</code>) may be called before a preceding read call
has called back.</p>
<h3 id="handling-end-abort-error-in-through-streams">handling end/abort/error in through streams</h3>
<p>Rules for implementing <code>read</code> in a through stream:
1) Sink wants to stop. sink aborts the through</p>
<pre><code>just forward the exact read() call to your source,
any future read calls should cb(true).
</code></pre><p>2) We want to stop. (abort from the middle of the stream)</p>
<pre><code>abort your source, and then cb(true) to tell the sink we have ended.
If the source errored during abort, end the sink by cb read with `cb(err)`.
(this will be an ordinary end/error for the sink)
</code></pre><p>3) Source wants to stop. (<code>read(null, cb) -&gt; cb(err||true)</code>)</p>
<pre><code>forward that exact callback towards the sink chain,
we must respond to any future read calls with `cb(err||true)`.
</code></pre><p>In none of the above cases data is flowing!
4) If data is flowing (normal operation:   <code>read(null, cb) -&gt; cb(null, data)</code></p>
<pre><code>forward data downstream (towards the Sink)
do none of the above!
</code></pre><p>There either is data flowing (4) OR you have the error/abort cases (1-3), never both.</p>
<h2 id="license">License</h2>
<p>MIT</p>

      </div>
    </body>
  </html>